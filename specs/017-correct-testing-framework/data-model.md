# Data Model: Testing Framework Entities

## Overview
This document defines the core entities, relationships, and state transitions for the IRIS PGWire testing framework modernization.

## Core Entities

### 1. TestConfiguration
**Purpose**: Centralized pytest configuration settings
**Lifecycle**: Loaded at pytest startup, immutable during test session
**Location**: `pytest.ini` or `pyproject.toml`

**Fields**:
```python
class TestConfiguration:
    timeout_seconds: int = 30              # Global timeout threshold
    sequential_only: bool = True           # Disable parallel execution
    coverage_enabled: bool = True          # Track coverage (informational)
    coverage_threshold: Optional[int] = None  # No enforcement thresholds
    flaky_retries: int = 0                # Default: no automatic retries
    diagnostic_capture: bool = True        # Enable diagnostic hooks
    iris_host: str = "localhost"          # Embedded IRIS connection
    iris_port: int = 1972
    iris_namespace: str = "USER"
```

**Validation Rules**:
- `timeout_seconds` must be > 0 and ≤ 300 (5 minutes max)
- `coverage_threshold` must be None (informational only per spec)
- `sequential_only` must be True (per spec requirements)

**Relationships**:
- Consumed by: `TimeoutHandler`, `TestFixture`, `DiagnosticContext`

---

### 2. TestFixture
**Purpose**: Pytest fixtures for embedded IRIS setup/teardown
**Lifecycle**: Session-scoped or function-scoped based on resource type
**Location**: `tests/conftest.py`

**Fixture Types**:

#### Session-Scoped Fixtures
```python
@pytest.fixture(scope="session")
def embedded_iris() -> iris.Connection:
    """
    Provides shared IRIS connection for test session.

    Lifecycle:
    - Setup: Initialize IRIS connection pool, verify CallIn enabled
    - Yield: iris.Connection instance
    - Teardown: Close all pooled connections
    """
    pass

@pytest.fixture(scope="session")
def iris_config() -> dict:
    """
    Returns IRIS connection configuration.

    Fields: host, port, namespace, username, password
    """
    pass
```

#### Function-Scoped Fixtures
```python
@pytest.fixture(scope="function")
def iris_clean_namespace(embedded_iris) -> iris.Connection:
    """
    Provides isolated namespace for each test.

    Lifecycle:
    - Setup: Create transaction or snapshot namespace state
    - Yield: iris.Connection with clean state
    - Teardown: Drop test tables, rollback changes
    """
    pass

@pytest.fixture(scope="function")
def pgwire_client(embedded_iris) -> psycopg.Connection:
    """
    Provides PGWire protocol client for E2E tests.

    Lifecycle:
    - Setup: Start PGWire server (if not running), connect client
    - Yield: psycopg.Connection instance
    - Teardown: Close client connection
    """
    pass
```

**Relationships**:
- Depends on: `TestConfiguration`, `embedded_iris` (for function-scoped)
- Used by: All integration and E2E tests
- Monitored by: `TimeoutHandler`

---

### 3. TestReport
**Purpose**: Execution results and metrics
**Lifecycle**: Created per test execution, persisted to JSON/JSONL
**Location**: Generated by pytest reporting hooks

**Fields**:
```python
class TestReport:
    test_id: str                    # pytest node ID (e.g., tests/test_foo.py::test_bar)
    status: TestStatus              # PASSED, FAILED, TIMEOUT, SKIPPED
    duration_ms: float              # Execution time in milliseconds
    timeout_triggered: bool         # Whether test exceeded timeout
    diagnostic_context: Optional[DiagnosticContext]
    coverage_percent: Optional[float]  # Line coverage for this test
    flaky_status: FlakyStatus      # CONSISTENT, INTERMITTENT, UNKNOWN
    timestamp: datetime

class TestStatus(Enum):
    PASSED = "passed"
    FAILED = "failed"
    TIMEOUT = "timeout"
    SKIPPED = "skipped"

class FlakyStatus(Enum):
    CONSISTENT = "consistent"      # Always passes or always fails
    INTERMITTENT = "intermittent"  # Sometimes passes, sometimes fails
    UNKNOWN = "unknown"            # Insufficient data
```

**Validation Rules**:
- `duration_ms` must be > 0
- `timeout_triggered` is True if `duration_ms` ≥ `timeout_seconds * 1000`
- `flaky_status` requires ≥ 3 test runs to determine

**Relationships**:
- Created by: pytest reporting hooks (`pytest_runtest_makereport`)
- Contains: `DiagnosticContext` on failures/timeouts
- Consumed by: CI/CD reporting, flaky test analysis

---

### 4. TimeoutHandler
**Purpose**: Monitor test execution time and terminate hanging processes
**Lifecycle**: Active during test execution
**Location**: `tests/conftest.py` (pytest hook integration)

**Fields**:
```python
class TimeoutHandler:
    timeout_seconds: int = 30
    test_id: str
    start_time: float              # perf_counter() timestamp
    monitoring_thread: Thread      # Background thread for monitoring
    diagnostic_captured: bool = False
```

**Methods**:
```python
def monitor_test(test_id: str, timeout_seconds: int = 30) -> Optional[DiagnosticContext]:
    """
    Start monitoring test execution.

    Returns: DiagnosticContext if timeout triggered, None on success
    Side Effects: Terminates hanging process after timeout
    """

def capture_diagnostics() -> DiagnosticContext:
    """
    Capture IRIS state, connection info, query history.
    Called when timeout threshold exceeded.
    """

def terminate_process():
    """
    Kill hanging test process cleanly.
    Ensures IRIS connections are closed.
    """
```

**State Transitions**:
```
IDLE → MONITORING (test starts)
MONITORING → TIMEOUT_DETECTED (elapsed ≥ threshold)
TIMEOUT_DETECTED → DIAGNOSTIC_CAPTURE (capture state)
DIAGNOSTIC_CAPTURE → PROCESS_KILL (terminate)
PROCESS_KILL → IDLE (cleanup complete)
```

**Relationships**:
- Triggered by: pytest hooks (`pytest_runtest_call`)
- Creates: `DiagnosticContext` on timeout
- Updates: `TestReport.timeout_triggered`

---

### 5. DiagnosticContext
**Purpose**: Capture system state on test failure or timeout
**Lifecycle**: Created on test failure/timeout, attached to TestReport
**Location**: Generated by pytest hooks and TimeoutHandler

**Fields**:
```python
class DiagnosticContext:
    test_id: str
    failure_type: str              # "timeout", "assertion", "exception"

    # IRIS State
    iris_connection_state: str     # "connected", "disconnected", "hung"
    iris_namespace: str
    iris_query_history: List[str]  # Last 10 SQL statements executed
    iris_process_id: Optional[int]

    # Test Environment
    fixture_stack: List[str]       # Active fixtures when failure occurred
    stack_trace: str               # Full Python stack trace

    # Timing
    elapsed_ms: float
    timeout_threshold_ms: float

    # Additional Context
    environment_vars: Dict[str, str]  # Relevant env vars (IRIS_*, PGWIRE_*)
    log_excerpt: str               # Last 50 lines of test output
```

**Relationships**:
- Created by: `TimeoutHandler`, pytest failure hooks
- Attached to: `TestReport`
- Consumed by: Test failure analysis, CI/CD dashboards

---

## Entity Relationships

```
TestConfiguration
    ↓ configures
TimeoutHandler
    ↓ monitors
TestFixture (embedded_iris, iris_clean_namespace)
    ↓ used by
Test Execution
    ↓ produces
TestReport
    ↓ may contain
DiagnosticContext
```

## State Transition Diagram

### Test Execution Flow
```
┌─────────┐
│ PENDING │ Test discovered by pytest
└────┬────┘
     │
     ↓
┌─────────────┐
│ IN_PROGRESS │ Fixture setup + test body
└──┬──┬──┬───┘
   │  │  │
   │  │  └─── (timeout) ──→ TIMEOUT
   │  │
   │  └────── (assertion/exception) ──→ FAILED
   │
   └───────── (no errors) ──→ PASSED
```

### Timeout Detection Flow
```
┌─────────────┐
│ IN_PROGRESS │ Test running, timer started
└──────┬──────┘
       │
       ↓ (elapsed ≥ 30s)
┌─────────────────┐
│ TIMEOUT_DETECTED│ TimeoutHandler triggered
└──────┬──────────┘
       │
       ↓
┌────────────────────┐
│ DIAGNOSTIC_CAPTURE │ Capture IRIS state, connection info
└──────┬─────────────┘
       │
       ↓
┌──────────────┐
│ PROCESS_KILL │ Terminate hanging test process
└──────┬───────┘
       │
       ↓
┌─────────────┐
│ CLEANUP     │ Close IRIS connections, reset state
└──────┬──────┘
       │
       ↓
┌─────────────┐
│ REPORTED    │ TestReport created with timeout status
└─────────────┘
```

## Validation Rules Summary

### TestConfiguration
- ✅ `timeout_seconds` in range [1, 300]
- ✅ `sequential_only == True` (constitutional requirement)
- ✅ `coverage_threshold == None` (informational only)

### TestFixture
- ✅ Session-scoped fixtures complete setup in < 10 seconds
- ✅ Function-scoped fixtures complete cleanup in < 2 seconds
- ✅ IRIS connection must be valid before yielding

### TestReport
- ✅ `duration_ms > 0`
- ✅ `timeout_triggered` matches actual timeout condition
- ✅ `flaky_status` determined from ≥ 3 runs

### DiagnosticContext
- ✅ `stack_trace` must be non-empty for failures
- ✅ `iris_query_history` captures last 10 queries
- ✅ `elapsed_ms` matches TestReport duration

## Implementation Notes

1. **Connection Pooling**: Session-scoped `embedded_iris` fixture maintains connection pool (max 10 connections)
2. **Transaction Isolation**: Function-scoped fixtures use transaction rollback for cleanup
3. **Timeout Precision**: Use `time.perf_counter()` for microsecond-precision timing
4. **Diagnostic Storage**: JSONL format for easy parsing and analysis across test runs
5. **IRIS State Capture**: Query `%SYS.ProcessQuery` for hanging process detection
